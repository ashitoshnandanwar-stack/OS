# Operating System

| Feature              | Operating System                    | Application Software         |
| -------------------- | ----------------------------------- | ---------------------------- |
| Purpose              | Manages hardware & system resources | Performs user-specific tasks |
| Dependency           | Works directly with hardware        | Runs on OS                   |
| Execution            | Starts when computer boots          | Starts after OS loads        |
| Hardware Interaction | Direct interaction                  | No direct interaction        |
| Example              | Windows, Linux                      | MS Word, Browser, Photoshop  |
| Mandatory            | Yes (system cannot run without it)  | No (optional)                |

- OS is hardware dependent because it directly controls and communicates with hardware using device drivers and CPU instructions.
- OS acts as interface between user and hardware.
- OS is also known as Resource Manager.
- Kernel ‚Üí heart of OS, always in memory, communicates with CPU, memory, and devices, Responsibility resource allocation
- Device drivers ‚Üí hardware control
- OS = system software + resource manager
- Hardware dependent ‚Üí OS, Drivers
- Interface between OS and user -> shell
- Memory managed by OS - both primary and secondary
- Multiple programs in memory - multiprogramming

<img width="402" height="402" alt="image" src="https://github.com/user-attachments/assets/b4c7cf8d-1c45-4acd-b829-c8e9a0e521d6" />

## Different component of OS

1. kernel
```
Definition
The kernel is the central and most important component of the OS. It directly interacts with hardware.
üîπ Functions
Process management
Memory management
Device management
Interrupt handling
Resource allocation
```

2.Process Manaagement
```
üîπ Functions
CPU scheduling is a function of process management
Context switching
Process states (New, Ready, Running, Waiting, Terminated)
Deadlock handling
```

3.Memory Management
```
Manages primary (RAM) and secondary memory (disk).
üîπ Functions
Allocation & deallocation
Paging & segmentation
Virtual memory
Protection of memory space
```

4.File System Management
```
Manages files and directories on storage devices.
üîπ Functions
File creation, deletion
Directory management
Access permissions
File naming and protection
```

5.Device Management
```
Controls and coordinates I/O devices.
üîπ Key Element
Device drivers
üîπ Functions
I/O scheduling
Buffering
Spooling
Interrupt handling
```

6.I/O Management
```
Handles input and output operations efficiently.
üîπ Functions
Buffering
Caching
Spooling
Interrupt-based I/O
```

7.Security & Protection
```
Prevents unauthorized access to system resources.
üîπ Includes
User authentication
Authorization
Access control
Protection mechanisms
```

8.Shell (User Interface)
```
Shell is the interface between user and kernel.
üîπ Types
CLI (Command Line Interface)
GUI (Graphical User Interface)
```

9.System Utilities (Supporting Programs)
```
üîπ Examples
Disk cleanup
Antivirus
Backup tools
üîπ Purpose
Assist in system maintenance (not core OS).
```

| Component          | Main Function       |
| ------------------ | ------------------- |
| Kernel             | Resource management |
| Process Management | CPU scheduling      |
| Memory Management  | RAM & disk handling |
| File System        | Files & directories |
| Device Management  | Hardware control    |
| I/O Management     | Input/output        |
| Security           | Protection          |
| Shell              | User interface      |

- Spooling means temporarily storing data in a buffer or intermediate storage area before it's processed or sent to its final destination.

## What is an Interrupt?
```
An interrupt is a signal that temporarily stops the CPU to handle an urgent event.

üîπ Types of Interrupts
Hardware interrupt ‚Äì keyboard, mouse, I/O device
Software interrupt ‚Äì generated by programs
Timer interrupt ‚Äì for CPU scheduling

üìå MCQ Line:
üëâ Interrupts are handled by the kernel.

üîπ Why Interrupts are Needed?
Efficient CPU utilization
Multitasking
Quick response to I/O events
```

## System Call
```
What is a System Call?
A system call is a mechanism by which a user program requests services from the OS kernel.

üîπ Examples
read()
write()
open()
fork()

üìå MCQ Line:
üëâ System calls provide an interface between user programs and OS.

üîπ Why System Calls are Needed?
User programs cannot directly access hardware
Ensures controlled and secure access

```

| Feature     | Interrupt                 | System Call        |
| ----------- | ------------------------- | ------------------ |
| Trigger     | Hardware / software event | User program       |
| Nature      | Asynchronous              | Synchronous        |
| Purpose     | Handle urgent events      | Request OS service |
| Mode switch | Yes                       | Yes                |


## Linux
- Linux is a free, open-source, multiuser, multitasking operating system based on UNIX.

```
üîπ Key Features
Open source
Portable (runs on many hardware platforms)
Multiuser & multitasking
Secure and stable
CLI (Command Line Interface) based (also GUI available)
```

üîπ Important Directories
| Directory | Purpose                        |
| --------- | ------------------------------ |
| `/`       | Root directory                 |
| `/home`   | User home directories          |
| `/bin`    | Essential user commands        |
| `/sbin`   | System administration commands |
| `/etc`    | Configuration files            |
| `/dev`    | Device files                   |
| `/proc`   | Process & kernel info          |
| `/var`    | Variable files (logs, mail)    |
| `/tmp`    | Temporary files                |


üìÅ Directory Commands
| Command | Use                    |
| ------- | ---------------------- |
| `pwd`   | Show current directory |
| `ls`    | List files/directories |
| `cd`    | Change directory       |
| `mkdir` | Create directory       |
| `rmdir` | Delete empty directory |


üìÑ File Commands
| Command | Use                  |
| ------- | -------------------- |
| `touch` | Create empty file    |
| `cat`   | Display file content |
| `cp`    | Copy file            |
| `mv`    | Move/rename file     |
| `rm`    | Delete file          |

‚öôÔ∏è Other Basic Linux Commands
| Command  | Function            |
| -------- | ------------------- |
| `whoami` | Show current user   |
| `date`   | Display system date |
| `clear`  | Clear terminal      |
| `man`    | Manual/help         |
| `echo`   | Print message       |

## üîÅ Operators in Linux

1Ô∏è‚É£ Redirection Operators
- Redirection is used to redirect input/output.

| Operator | Meaning                        |
| -------- | ------------------------------ |
| `>`      | Output redirection (overwrite) |
| `>>`     | Output redirection (append)    |
| `<`      | Input redirection              |

```
ls > files.txt        # overwrite output
ls >> files.txt       # append output
sort < data.txt       # input redirection
```

2Ô∏è‚É£ Pipe Operator (|)
- The pipe operator sends output of one command as input to another.
- Connect commands
- command1 | command2
```
ls | wc -l        # count files
ps -ef | grep root
```

## üîê File Permissions in Linux
- File permissions define who can read, write, or execute a file/directory.

```
üë• Permission Classes
User (u) ‚Äì file owner
Group (g) ‚Äì group members
Others (o) ‚Äì everyone else

üîë Permission Types
r (read) = 4
w (write) = 2
x (execute) = 1

- rwx r-x r--
  rwx ‚Üí user (give all permission) - 7
  r-x ‚Üí group (read and execute permission) - 5
  r-- ‚Üí others (only read permission) - 4

```

<img width="660" height="386" alt="image" src="https://github.com/user-attachments/assets/5ec15843-cd00-4985-b075-34b61b2cb96a" />

<img width="569" height="243" alt="image" src="https://github.com/user-attachments/assets/eb8baa1e-76a1-4a4e-a53f-2b33f75d72b9" />

| Number | Permission |
| ------ | ---------- |
| 7      | rwx        |
| 6      | rw-        |
| 5      | r-x        |
| 4      | r--        |

## üë§ Changing Ownership ‚Äì chown & chgrp

```
chown user file.txt
chown user:group file.txt

chgrp group file.txt
```

## ACL (Access Control List) 
- it is basically a list of rules that says who can do what with a file, folder, or system resource.
- ACL provides fine-grained permissions beyond user/group/others.

| Command | Purpose       | Security   |
| ------- | ------------- | ---------- |
| telnet  | Remote login  |  Insecure  |
| ftp     | File transfer |  Insecure  |
| ssh     | Remote login  |  Secure    |
| sftp    | File transfer |  Secure    |
| finger  | User info     |    ‚Äì       |

## üß© System (Shell) Variables in Linux
- System variables (shell variables) control the behavior and appearance of the shell. They are widely used in Bash.

| Variable | Purpose                 |
| -------- | --------------------    |
| PS1      | Primary shell prompt (/)|
| PS2      | Continuation prompt (>) |
| PS3      | Select loop prompt      |
| PS4      | Debug prompt            |

## üêö Shell Programming ‚Äì Introduction

```
üîπ What is a Shell?
A shell is a command-line interpreter that:
Takes commands from the user
Interprets them
Executes them via the OS kernel

üìå Exam Line:
üëâ Shell acts as an interface between user and kernel.

üîπ Role of Shell
Command execution
Script execution
Variable handling
Input/output redirection
Process control
```

### üß© Different Shells in Linux

<img width="500" height="301" alt="image" src="https://github.com/user-attachments/assets/6bf0fdf5-bf65-4a9d-9e8d-18f04a321e47" />

| Shell  | Name               | Features                        |
| ------ | ------------------ | ------------------------------- |
| `sh`   | Bourne Shell       | Original UNIX shell             |
| `bash` | Bourne Again Shell | Most popular, scripting support |
| `csh`  | C Shell            | C-like syntax                   |
| `ksh`  | Korn Shell         | Advanced scripting              |
| `zsh`  | Z Shell            | Auto-completion, customization  |

### ‚≠ê Wildcard Symbols (Filename Expansion)

| Wildcard | Meaning                          |
| -------- | -------------------------------- |
| `*`      | Matches any number of characters |
| `?`      | Matches exactly one character    |
| `[a-z]`  | Matches a range                  |

### ‚öôÔ∏è Shell Meta Characters

<img width="1024" height="768" alt="image" src="https://github.com/user-attachments/assets/384218d4-d1fd-4cac-910a-2981fa2ab33a" />

| Symbol   | Meaning              |      |
| -------- | -------------------- | ---- |
| `>`      | Output redirection   |      |
| `<`      | Input redirection    |      |
| `>>`     | Append               |      |
| `        | `                    | Pipe |
| `;`      | Command separator    |      |
| `&`      | Background execution |      |
| `* ? []` | Wildcards            |      |


### üßÆ Command Line Arguments

<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/465470c7-5fe4-4ab9-afb3-901b3df58047" />

| Parameter | Meaning             |
| --------- | ------------------- |
| `$0`      | Script name         |
| `$1`      | First argument      |
| `$2`      | Second argument     |
| `$#`      | Number of arguments |
| `$@`      | All arguments       |

| Topic          | Key Point                       |        |
| -------------- | ------------------------------- | ------ |
| Shell          | Interface between user & kernel |        |
| Default Shell  | bash                            |        |
| Variables      | name=value                      |        |
| Wildcards      | *, ?, []                        |        |
| Metacharacters | >, <,                           | , ;, & |
| Arguments      | $1, $2, $#                      |        |
| read           | Input                           |        |
| echo           | Output                          |        |


### Common test Operators

| Operator | Meaning       |
| -------- | ------------- |
| -eq      | equal         |
| -ne      | not equal     |
| -gt      | greater than  |
| -lt      | less than     |
| -ge      | greater/equal |
| -le      | less/equal    |

### Common Regex Symbols

| Symbol   | Meaning              |
| -------- | -------------------- |
| `.`      | Any single character |
| `*`      | Zero or more         |
| `^`      | Start of line        |
| `$`      | End of line          |
| `[a-z]`  | Range                |
| `[^a-z]` | Negation             |

| Topic         | Key Point          |
| ------------- | ------------------ |
| if / else     | Decision making    |
| test          | Condition checking |
| case          | Multiple choices   |
| while         | Condition true     |
| until         | Condition false    |
| for           | Fixed iteration    |
| Regex         | Pattern matching   |
| expr / $(( )) | Arithmetic         |
| grep          | Regex search       |

- echo is used to display them, and read is used to take input from the user at runtime.

### Regular Expressions (Basics)
- Used with commands like grep, sed, awk.

| Symbol  | Meaning                  |
| ------- | ------------------------ |
| `.`     | Any single character     |
| `^`     | Start of line            |
| `$`     | End of line              |
| `*`     | Zero or more occurrences |
| `[a-z]` | Range                    |
| `+`     | One or more              |

```
grep "^A" names.txt      # Lines starting with A
grep "ing$" words.txt    # Lines ending with ing
grep "[0-9]" file.txt    # Lines containing digits
```

### Arithmetic Expressions
using expr:
```
a=10
b=5
c=`expr $a + $b`
echo $c
```
Using $(( )) (recommended):
```
sum=$((a+b))
mul=$((a*b))
echo $sum
echo $mul
```

<hr>

## Process
- A process is a program that is currently in execution.
It includes:
```
Program code
Current values of variables
CPU registers
Memory (stack, heap, data section)
State (ready, running, waiting, etc.)

Example:
When you open a browser, the browser program becomes a process in memory.
```
### Types of Process
1. üîπ Preemptive Process (Preemptive Scheduling)
- In preemptive systems, the operating system can interrupt a running process and give the CPU to another process.
- CPU is taken away before the process finishes.
- Used in time-sharing and multitasking systems.
- Improves responsiveness.

Examples:
- Round Robin Scheduling
- Shortest Remaining Time First (SRTF)
- Priority Scheduling (preemptive)

Real-life example:
```
While watching a video, a notification arrives. The OS pauses the video process briefly to handle the notification.
```

2. üîπ Non-Preemptive Process (Non-Preemptive Scheduling)
- In non-preemptive systems, once a process gets the CPU, it keeps it until it finishes or enters a waiting state.
- No forced interruption by OS.
- Simpler but less responsive.

Examples:
```
First Come First Serve (FCFS)
Shortest Job First (SJF ‚Äì non-preemptive)
Priority Scheduling (non-preemptive)

Real-life example:
A printer printing a large file: it completes the current job before starting the next one.
```

| Feature       | Preemptive           | Non-Preemptive       |
| ------------- | -------------------- | -------------------- |
| CPU control   | OS can interrupt     | Process releases CPU |
| Response time | Fast                 | Slow                 |
| Complexity    | More complex         | Simple               |
| Use case      | Multitasking systems | Batch systems        |
| Examples      | Round Robin, SRTF    | FCFS, SJF            |

### Difference Between Process and Thread

| Process                                | Thread                           |
| -------------------------------------- | -------------------------------- |
| Heavyweight                            | Lightweight                      |
| Has its own memory space               | Shares memory with other threads |
| Context switch is slow                 | Context switch is fast           |
| More secure                            | Less secure                      |
| Inter-process communication is complex | Communication is easy            |

### Process Management & Life Cycle
Process states:
```
New ‚Üí Ready ‚Üí Running ‚Üí Waiting ‚Üí Ready ‚Üí Terminated

New ‚Äì Process is created
Ready ‚Äì Waiting for CPU
Running ‚Äì Executing
Waiting/Blocked ‚Äì Waiting for I/O
Terminated ‚Äì Finished execution
```
OS manages processes using PCB (Process Control Block).

- A Process Control Block (PCB) is a data structure used by the Operating System to store all information about a process.
- PCB is the identity card of a process.
```
+---------------------------+
|     Process Control Block |
+---------------------------+
| Process ID (PID)          |
| Process State             |
| Program Counter           |
| CPU Registers             |
| Scheduling Information    |
| Memory Management Info    |
| Accounting Information    |
| I/O Status Information    |
+---------------------------+
```
### Schedulers
- A Scheduler is a component of the Operating System that decides which process will get the CPU and for how long.
- In a multiprogramming system, many processes are in memory at the same time. The scheduler selects one process from the ready queue and allocates the CPU to it.
- In simple words: Scheduler = CPU manager

üîπ Types of Schedulers
1. Long-Term Scheduler (Job Scheduler)
```
Selects processes from disk and loads them into memory.
Controls the degree of multiprogramming.
Invoked less frequently.
```
2. Short-Term Scheduler (CPU Scheduler)
```
Selects one process from the ready queue to execute on CPU.
Invoked very frequently (milliseconds).
Most important for CPU utilization and response time.
```
3. Medium-Term Scheduler
```
Suspends and resumes processes.
Used in swapping (moving processes in/out of memory).
```

| Scheduler       | Function                                              |
| --------------- | ----------------------------------------------------- |
| **Long-Term**   | Selects processes from job pool and loads into memory |
| **Medium-Term** | Suspends/resumes processes (swapping)                 |
| **Short-Term**  | Selects which ready process gets CPU                  |

## Process Scheduling Algorithms
```
FCFS (First Come First Serve)
SJF (Shortest Job First)
Priority Scheduling
Round Robin (RR)
Multilevel Queue Scheduling
Belady‚Äôs Anomaly ‚Äì In paging, increasing frames may increase page faults (seen in FIFO).
```
| Scheduling Type                      | Preemptive / Non-Preemptive | Key Idea / Rule                             | Main Advantage               | Main Disadvantage                 |
| ------------------------------------ | --------------------------- | ------------------------------------------- | ---------------------------- | --------------------------------- |
| FCFS (First Come First Serve)        | Non-Preemptive              | First arrived process runs first            | Simple, fair by arrival      | High waiting time, convoy effect  |
| SJF (Shortest Job First)             | Both (Pre / Non)            | Shortest burst time first                   | Minimum average waiting time | Starvation, hard to predict burst |
| SRTF (Shortest Remaining Time First) | Preemptive                  | Shortest *remaining* time runs first        | Very efficient               | Complex, starvation               |
| Priority Scheduling                  | Both (Pre / Non)            | Highest priority runs first                 | Important tasks first        | Starvation, priority inversion    |
| Round Robin (RR)                     | Preemptive                  | Each process gets fixed time quantum        | Fair, good response time     | Context switch overhead           |
| Multilevel Queue                     | Both                        | Separate queues for different process types | Organized, predictable       | Starvation of lower queues        |
| Multilevel Feedback Queue            | Preemptive                  | Processes can move between queues           | Flexible, avoids starvation  | Complex to implement              |

- Time Quantum (also called Time Slice) is a fixed amount of CPU time given to each process in Round Robin (RR) scheduling.

### Example: Turnaround Time Comparison

| Process | Burst Time |
| ------- | ---------- |
| P1      | 6          |
| P2      | 8          |
| P3      | 7          |
| P4      | 3          |

FCFS Order: P1 ‚Üí P2 ‚Üí P3 ‚Üí P4
Completion Times:
```
P1 = 6
P2 = 14
P3 = 21
P4 = 24
```
- Turnaround Time = Completion Time ‚Äì Arrival Time (0)  = 24
- Average TAT = (6 + 14 + 21 + 24) / 4 = 16.25

SJF Order: P4 ‚Üí P1 ‚Üí P3 ‚Üí P2
```
In SJF(Shortest Job First) scheduling, processes are executed in the order of their CPU burst time (job length):
Shortest burst time ‚Üí Executed first
```
Completion Times:
```
P4 = 3
P1 = 9
P3 = 16
P2 = 24
```
- Average TAT = (3 + 9 + 16 + 24) / 4 = 13

- üëâ SJF performs better (less average turnaround time).


### Process Creation in UNIX
- System calls:
```
fork() ‚Äì Creates a new process
waitpid() ‚Äì Parent waits for child
exec() ‚Äì Replaces process image
```
```
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("Child Process\n");
        execlp("ls", "ls", NULL);
    } else {
        waitpid(pid, NULL, 0);
        printf("Parent Process\n");
    }
    return 0;
}

fork() returns 0 to child and PID to parent.
exec() loads a new program into the process.
```

### Parent and Child Processes
- Process that calls fork() ‚Üí Parent
- Newly created process ‚Üí Child
- Child has a different PID but same code initially.

### üîπ Orphan Process
- An orphan process is a process whose parent process has terminated while the child is still running.
- The child process loses its parent.
- In UNIX/Linux, such a process is adopted by the init <b>(PID 1) or systemd<b> process.
- It continues execution normally.
Example:
```
A parent program starts a child and then exits immediately.
The child keeps running ‚Üí it becomes an orphan process.
```

###  üîπ Zombie Process
- A zombie process is a process that has completed execution, but still has an entry in the process table.
- It has finished, but its parent has not collected its exit status using wait().
- It does not use CPU or memory, only a small process table entry.
- Shown as <b>Z<b> state in ps command.
Example:
```
Child process ends, but parent is still running and does not call wait().
The child becomes a zombie process.
```

Zombie example:
```
if (fork() == 0) {
    exit(0);   // Child exits
} else {
    sleep(30); // Parent does not wait
}
During sleep, child becomes a zombie.
```

| Feature        | Orphan Process            | Zombie Process                |
| -------------- | ------------------------- | ----------------------------- |
| State          | Still running             | Terminated (dead)             |
| Parent         | Parent has terminated     | Parent is alive               |
| Resource Usage | Uses CPU and memory       | Uses only process table entry |
| Solution       | Adopted by `init/systemd` | Parent must call `wait()`     |
| Linux State    | Normal running process    | `Z` (defunct)                 |
