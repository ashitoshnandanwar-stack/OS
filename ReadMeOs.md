# Operating System

| Feature              | Operating System                    | Application Software         |
| -------------------- | ----------------------------------- | ---------------------------- |
| Purpose              | Manages hardware & system resources | Performs user-specific tasks |
| Dependency           | Works directly with hardware        | Runs on OS                   |
| Execution            | Starts when computer boots          | Starts after OS loads        |
| Hardware Interaction | Direct interaction                  | No direct interaction        |
| Example              | Windows, Linux                      | MS Word, Browser, Photoshop  |
| Mandatory            | Yes (system cannot run without it)  | No (optional)                |

- OS is hardware dependent because it directly controls and communicates with hardware using device drivers and CPU instructions.
- OS acts as interface between user and hardware.
- OS is also known as Resource Manager.
- Kernel ‚Üí heart of OS, always in memory, communicates with CPU, memory, and devices, Responsibility resource allocation
- Device drivers ‚Üí hardware control
- OS = system software + resource manager
- Hardware dependent ‚Üí OS, Drivers
- Interface between OS and user -> shell
- Memory managed by OS - both primary and secondary
- Multiple programs in memory - multiprogramming

<img width="402" height="402" alt="image" src="https://github.com/user-attachments/assets/b4c7cf8d-1c45-4acd-b829-c8e9a0e521d6" />

## Different component of OS

1. kernel
```
Definition
The kernel is the central and most important component of the OS. It directly interacts with hardware.
üîπ Functions
Process management
Memory management
Device management
Interrupt handling
Resource allocation
```

2.Process Manaagement
```
üîπ Functions
CPU scheduling is a function of process management
Context switching
Process states (New, Ready, Running, Waiting, Terminated)
Deadlock handling
```

3.Memory Management
```
Manages primary (RAM) and secondary memory (disk).
üîπ Functions
Allocation & deallocation
Paging & segmentation
Virtual memory
Protection of memory space
```

4.File System Management
```
Manages files and directories on storage devices.
üîπ Functions
File creation, deletion
Directory management
Access permissions
File naming and protection
```

5.Device Management
```
Controls and coordinates I/O devices.
üîπ Key Element
Device drivers
üîπ Functions
I/O scheduling
Buffering
Spooling
Interrupt handling
```

6.I/O Management
```
Handles input and output operations efficiently.
üîπ Functions
Buffering
Caching
Spooling
Interrupt-based I/O
```

7.Security & Protection
```
Prevents unauthorized access to system resources.
üîπ Includes
User authentication
Authorization
Access control
Protection mechanisms
```

8.Shell (User Interface)
```
Shell is the interface between user and kernel.
üîπ Types
CLI (Command Line Interface)
GUI (Graphical User Interface)
```

9.System Utilities (Supporting Programs)
```
üîπ Examples
Disk cleanup
Antivirus
Backup tools
üîπ Purpose
Assist in system maintenance (not core OS).
```

| Component          | Main Function       |
| ------------------ | ------------------- |
| Kernel             | Resource management |
| Process Management | CPU scheduling      |
| Memory Management  | RAM & disk handling |
| File System        | Files & directories |
| Device Management  | Hardware control    |
| I/O Management     | Input/output        |
| Security           | Protection          |
| Shell              | User interface      |

- Spooling means temporarily storing data in a buffer or intermediate storage area before it's processed or sent to its final destination.

## What is an Interrupt?
```
An interrupt is a signal that temporarily stops the CPU to handle an urgent event.

üîπ Types of Interrupts
Hardware interrupt ‚Äì keyboard, mouse, I/O device
Software interrupt ‚Äì generated by programs
Timer interrupt ‚Äì for CPU scheduling

üìå MCQ Line:
üëâ Interrupts are handled by the kernel.

üîπ Why Interrupts are Needed?
Efficient CPU utilization
Multitasking
Quick response to I/O events
```

## System Call
```
What is a System Call?
A system call is a mechanism by which a user program requests services from the OS kernel.

üîπ Examples
read()
write()
open()
fork()

üìå MCQ Line:
üëâ System calls provide an interface between user programs and OS.

üîπ Why System Calls are Needed?
User programs cannot directly access hardware
Ensures controlled and secure access

```

| Feature     | Interrupt                 | System Call        |
| ----------- | ------------------------- | ------------------ |
| Trigger     | Hardware / software event | User program       |
| Nature      | Asynchronous              | Synchronous        |
| Purpose     | Handle urgent events      | Request OS service |
| Mode switch | Yes                       | Yes                |


## Linux
- Linux is a free, open-source, multiuser, multitasking operating system based on UNIX.

```
üîπ Key Features
Open source
Portable (runs on many hardware platforms)
Multiuser & multitasking
Secure and stable
CLI (Command Line Interface) based (also GUI available)
```

üîπ Important Directories
| Directory | Purpose                        |
| --------- | ------------------------------ |
| `/`       | Root directory                 |
| `/home`   | User home directories          |
| `/bin`    | Essential user commands        |
| `/sbin`   | System administration commands |
| `/etc`    | Configuration files            |
| `/dev`    | Device files                   |
| `/proc`   | Process & kernel info          |
| `/var`    | Variable files (logs, mail)    |
| `/tmp`    | Temporary files                |


üìÅ Directory Commands
| Command | Use                    |
| ------- | ---------------------- |
| `pwd`   | Show current directory |
| `ls`    | List files/directories |
| `cd`    | Change directory       |
| `mkdir` | Create directory       |
| `rmdir` | Delete empty directory |


üìÑ File Commands
| Command | Use                  |
| ------- | -------------------- |
| `touch` | Create empty file    |
| `cat`   | Display file content |
| `cp`    | Copy file            |
| `mv`    | Move/rename file     |
| `rm`    | Delete file          |

‚öôÔ∏è Other Basic Linux Commands
| Command  | Function            |
| -------- | ------------------- |
| `whoami` | Show current user   |
| `date`   | Display system date |
| `clear`  | Clear terminal      |
| `man`    | Manual/help         |
| `echo`   | Print message       |

## üîÅ Operators in Linux

1Ô∏è‚É£ Redirection Operators
- Redirection is used to redirect input/output.

| Operator | Meaning                        |
| -------- | ------------------------------ |
| `>`      | Output redirection (overwrite) |
| `>>`     | Output redirection (append)    |
| `<`      | Input redirection              |

```
ls > files.txt        # overwrite output
ls >> files.txt       # append output
sort < data.txt       # input redirection
```

2Ô∏è‚É£ Pipe Operator (|)
- The pipe operator sends output of one command as input to another.
- Connect commands
- command1 | command2
```
ls | wc -l        # count files
ps -ef | grep root
```

## üîê File Permissions in Linux
- File permissions define who can read, write, or execute a file/directory.

```
üë• Permission Classes
User (u) ‚Äì file owner
Group (g) ‚Äì group members
Others (o) ‚Äì everyone else

üîë Permission Types
r (read) = 4
w (write) = 2
x (execute) = 1

- rwx r-x r--
  rwx ‚Üí user (give all permission) - 7
  r-x ‚Üí group (read and execute permission) - 5
  r-- ‚Üí others (only read permission) - 4

```

<img width="660" height="386" alt="image" src="https://github.com/user-attachments/assets/5ec15843-cd00-4985-b075-34b61b2cb96a" />

<img width="569" height="243" alt="image" src="https://github.com/user-attachments/assets/eb8baa1e-76a1-4a4e-a53f-2b33f75d72b9" />

| Number | Permission |
| ------ | ---------- |
| 7      | rwx        |
| 6      | rw-        |
| 5      | r-x        |
| 4      | r--        |

## üë§ Changing Ownership ‚Äì chown & chgrp

```
chown user file.txt
chown user:group file.txt

chgrp group file.txt
```

## ACL (Access Control List) 
- it is basically a list of rules that says who can do what with a file, folder, or system resource.
- ACL provides fine-grained permissions beyond user/group/others.

| Command | Purpose       | Security   |
| ------- | ------------- | ---------- |
| telnet  | Remote login  |  Insecure  |
| ftp     | File transfer |  Insecure  |
| ssh     | Remote login  |  Secure    |
| sftp    | File transfer |  Secure    |
| finger  | User info     |    ‚Äì       |

## üß© System (Shell) Variables in Linux
- System variables (shell variables) control the behavior and appearance of the shell. They are widely used in Bash.

| Variable | Purpose                 |
| -------- | --------------------    |
| PS1      | Primary shell prompt (/)|
| PS2      | Continuation prompt (>) |
| PS3      | Select loop prompt      |
| PS4      | Debug prompt            |

## üêö Shell Programming ‚Äì Introduction

```
üîπ What is a Shell?
A shell is a command-line interpreter that:
Takes commands from the user
Interprets them
Executes them via the OS kernel

üìå Exam Line:
üëâ Shell acts as an interface between user and kernel.

üîπ Role of Shell
Command execution
Script execution
Variable handling
Input/output redirection
Process control
```

### üß© Different Shells in Linux

<img width="500" height="301" alt="image" src="https://github.com/user-attachments/assets/6bf0fdf5-bf65-4a9d-9e8d-18f04a321e47" />

| Shell  | Name               | Features                        |
| ------ | ------------------ | ------------------------------- |
| `sh`   | Bourne Shell       | Original UNIX shell             |
| `bash` | Bourne Again Shell | Most popular, scripting support |
| `csh`  | C Shell            | C-like syntax                   |
| `ksh`  | Korn Shell         | Advanced scripting              |
| `zsh`  | Z Shell            | Auto-completion, customization  |

### ‚≠ê Wildcard Symbols (Filename Expansion)

| Wildcard | Meaning                          |
| -------- | -------------------------------- |
| `*`      | Matches any number of characters |
| `?`      | Matches exactly one character    |
| `[a-z]`  | Matches a range                  |

### ‚öôÔ∏è Shell Meta Characters

<img width="1024" height="768" alt="image" src="https://github.com/user-attachments/assets/384218d4-d1fd-4cac-910a-2981fa2ab33a" />

| Symbol   | Meaning              |      |
| -------- | -------------------- | ---- |
| `>`      | Output redirection   |      |
| `<`      | Input redirection    |      |
| `>>`     | Append               |      |
| `        | `                    | Pipe |
| `;`      | Command separator    |      |
| `&`      | Background execution |      |
| `* ? []` | Wildcards            |      |


### üßÆ Command Line Arguments

<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/465470c7-5fe4-4ab9-afb3-901b3df58047" />

| Parameter | Meaning             |
| --------- | ------------------- |
| `$0`      | Script name         |
| `$1`      | First argument      |
| `$2`      | Second argument     |
| `$#`      | Number of arguments |
| `$@`      | All arguments       |

| Topic          | Key Point                       |        |
| -------------- | ------------------------------- | ------ |
| Shell          | Interface between user & kernel |        |
| Default Shell  | bash                            |        |
| Variables      | name=value                      |        |
| Wildcards      | *, ?, []                        |        |
| Metacharacters | >, <,                           | , ;, & |
| Arguments      | $1, $2, $#                      |        |
| read           | Input                           |        |
| echo           | Output                          |        |


### Common test Operators

| Operator | Meaning       |
| -------- | ------------- |
| -eq      | equal         |
| -ne      | not equal     |
| -gt      | greater than  |
| -lt      | less than     |
| -ge      | greater/equal |
| -le      | less/equal    |

### Common Regex Symbols

| Symbol   | Meaning              |
| -------- | -------------------- |
| `.`      | Any single character |
| `*`      | Zero or more         |
| `^`      | Start of line        |
| `$`      | End of line          |
| `[a-z]`  | Range                |
| `[^a-z]` | Negation             |

| Topic         | Key Point          |
| ------------- | ------------------ |
| if / else     | Decision making    |
| test          | Condition checking |
| case          | Multiple choices   |
| while         | Condition true     |
| until         | Condition false    |
| for           | Fixed iteration    |
| Regex         | Pattern matching   |
| expr / $(( )) | Arithmetic         |
| grep          | Regex search       |

- echo is used to display them, and read is used to take input from the user at runtime.

### Regular Expressions (Basics)
- Used with commands like grep, sed, awk.

| Symbol  | Meaning                  |
| ------- | ------------------------ |
| `.`     | Any single character     |
| `^`     | Start of line            |
| `$`     | End of line              |
| `*`     | Zero or more occurrences |
| `[a-z]` | Range                    |
| `+`     | One or more              |

```
grep "^A" names.txt      # Lines starting with A
grep "ing$" words.txt    # Lines ending with ing
grep "[0-9]" file.txt    # Lines containing digits
```

### Arithmetic Expressions
using expr:
```
a=10
b=5
c=`expr $a + $b`
echo $c
```
Using $(( )) (recommended):
```
sum=$((a+b))
mul=$((a*b))
echo $sum
echo $mul
```

<hr>

## Process
- A process is a program that is currently in execution.
It includes:
```
Program code
Current values of variables
CPU registers
Memory (stack, heap, data section)
State (ready, running, waiting, etc.)

Example:
When you open a browser, the browser program becomes a process in memory.
```
### Types of Process
1. üîπ Preemptive Process (Preemptive Scheduling)
- In preemptive systems, the operating system can interrupt a running process and give the CPU to another process.
- CPU is taken away before the process finishes.
- Used in time-sharing and multitasking systems.
- Improves responsiveness.

Examples:
- Round Robin Scheduling
- Shortest Remaining Time First (SRTF)
- Priority Scheduling (preemptive)

Real-life example:
```
While watching a video, a notification arrives. The OS pauses the video process briefly to handle the notification.
```

2. üîπ Non-Preemptive Process (Non-Preemptive Scheduling)
- In non-preemptive systems, once a process gets the CPU, it keeps it until it finishes or enters a waiting state.
- No forced interruption by OS.
- Simpler but less responsive.

Examples:
```
First Come First Serve (FCFS)
Shortest Job First (SJF ‚Äì non-preemptive)
Priority Scheduling (non-preemptive)

Real-life example:
A printer printing a large file: it completes the current job before starting the next one.
```

| Feature       | Preemptive           | Non-Preemptive       |
| ------------- | -------------------- | -------------------- |
| CPU control   | OS can interrupt     | Process releases CPU |
| Response time | Fast                 | Slow                 |
| Complexity    | More complex         | Simple               |
| Use case      | Multitasking systems | Batch systems        |
| Examples      | Round Robin, SRTF    | FCFS, SJF            |

### Difference Between Process and Thread

| Process                                | Thread                           |
| -------------------------------------- | -------------------------------- |
| Heavyweight                            | Lightweight                      |
| Has its own memory space               | Shares memory with other threads |
| Context switch is slow                 | Context switch is fast           |
| More secure                            | Less secure                      |
| Inter-process communication is complex | Communication is easy            |

### Process Management & Life Cycle
Process states:
```
New ‚Üí Ready ‚Üí Running ‚Üí Waiting ‚Üí Ready ‚Üí Terminated

New ‚Äì Process is created
Ready ‚Äì Waiting for CPU
Running ‚Äì Executing
Waiting/Blocked ‚Äì Waiting for I/O
Terminated ‚Äì Finished execution
```
OS manages processes using PCB (Process Control Block).

- A Process Control Block (PCB) is a data structure used by the Operating System to store all information about a process.
- PCB is the identity card of a process.
```
+---------------------------+
|     Process Control Block |
+---------------------------+
| Process ID (PID)          |
| Process State             |
| Program Counter           |
| CPU Registers             |
| Scheduling Information    |
| Memory Management Info    |
| Accounting Information    |
| I/O Status Information    |
+---------------------------+
```
### Schedulers
- A Scheduler is a component of the Operating System that decides which process will get the CPU and for how long.
- In a multiprogramming system, many processes are in memory at the same time. The scheduler selects one process from the ready queue and allocates the CPU to it.
- In simple words: Scheduler = CPU manager

üîπ Types of Schedulers
1. Long-Term Scheduler (Job Scheduler)
```
Selects processes from disk and loads them into memory.
Controls the degree of multiprogramming.
Invoked less frequently.
```
2. Short-Term Scheduler (CPU Scheduler)
```
Selects one process from the ready queue to execute on CPU.
Invoked very frequently (milliseconds).
Most important for CPU utilization and response time.
```
3. Medium-Term Scheduler
```
Suspends and resumes processes.
Used in swapping (moving processes in/out of memory).
```

| Scheduler       | Function                                              |
| --------------- | ----------------------------------------------------- |
| **Long-Term**   | Selects processes from job pool and loads into memory |
| **Medium-Term** | Suspends/resumes processes (swapping)                 |
| **Short-Term**  | Selects which ready process gets CPU                  |

## Process Scheduling Algorithms
```
FCFS (First Come First Serve)
SJF (Shortest Job First)
Priority Scheduling
Round Robin (RR)
Multilevel Queue Scheduling
Belady‚Äôs Anomaly ‚Äì In paging, increasing frames may increase page faults (seen in FIFO).
```
| Scheduling Type                      | Preemptive / Non-Preemptive | Key Idea / Rule                             | Main Advantage               | Main Disadvantage                 |
| ------------------------------------ | --------------------------- | ------------------------------------------- | ---------------------------- | --------------------------------- |
| FCFS (First Come First Serve)        | Non-Preemptive              | First arrived process runs first            | Simple, fair by arrival      | High waiting time, convoy effect  |
| SJF (Shortest Job First)             | Both (Pre / Non)            | Shortest burst time first                   | Minimum average waiting time | Starvation, hard to predict burst |
| SRTF (Shortest Remaining Time First) | Preemptive                  | Shortest *remaining* time runs first        | Very efficient               | Complex, starvation               |
| Priority Scheduling                  | Both (Pre / Non)            | Highest priority runs first                 | Important tasks first        | Starvation, priority inversion    |
| Round Robin (RR)                     | Preemptive                  | Each process gets fixed time quantum        | Fair, good response time     | Context switch overhead           |
| Multilevel Queue                     | Both                        | Separate queues for different process types | Organized, predictable       | Starvation of lower queues        |
| Multilevel Feedback Queue            | Preemptive                  | Processes can move between queues           | Flexible, avoids starvation  | Complex to implement              |

- Time Quantum (also called Time Slice) is a fixed amount of CPU time given to each process in Round Robin (RR) scheduling.

### Example: Turnaround Time Comparison

| Process | Burst Time |
| ------- | ---------- |
| P1      | 6          |
| P2      | 8          |
| P3      | 7          |
| P4      | 3          |

FCFS Order: P1 ‚Üí P2 ‚Üí P3 ‚Üí P4
Completion Times:
```
P1 = 6
P2 = 14
P3 = 21
P4 = 24
```
- Turnaround Time = Completion Time ‚Äì Arrival Time (0)  = 24
- Average TAT = (6 + 14 + 21 + 24) / 4 = 16.25

SJF Order: P4 ‚Üí P1 ‚Üí P3 ‚Üí P2
```
In SJF(Shortest Job First) scheduling, processes are executed in the order of their CPU burst time (job length):
Shortest burst time ‚Üí Executed first
```
Completion Times:
```
P4 = 3
P1 = 9
P3 = 16
P2 = 24
```
- Average TAT = (3 + 9 + 16 + 24) / 4 = 13

- üëâ SJF performs better (less average turnaround time).


### Process Creation in UNIX
- System calls:
```
fork() ‚Äì Creates a new process
waitpid() ‚Äì Parent waits for child
exec() ‚Äì Replaces process image
```
```
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("Child Process\n");
        execlp("ls", "ls", NULL);
    } else {
        waitpid(pid, NULL, 0);
        printf("Parent Process\n");
    }
    return 0;
}

fork() returns 0 to child and PID to parent.
exec() loads a new program into the process.
```

### Parent and Child Processes
- Process that calls fork() ‚Üí Parent
- Newly created process ‚Üí Child
- Child has a different PID but same code initially.

### üîπ Orphan Process
- An orphan process is a process whose parent process has terminated while the child is still running.
- The child process loses its parent.
- In UNIX/Linux, such a process is adopted by the init <b>(PID 1) or systemd<b> process.
- It continues execution normally.
Example:
```
A parent program starts a child and then exits immediately.
The child keeps running ‚Üí it becomes an orphan process.
```

###  üîπ Zombie Process
- A zombie process is a process that has completed execution, but still has an entry in the process table.
- It has finished, but its parent has not collected its exit status using wait().
- It does not use CPU or memory, only a small process table entry.
- Shown as <b>Z<b> state in ps command.
Example:
```
Child process ends, but parent is still running and does not call wait().
The child becomes a zombie process.
```

Zombie example:
```
if (fork() == 0) {
    exit(0);   // Child exits
} else {
    sleep(30); // Parent does not wait
}
During sleep, child becomes a zombie.
```

| Feature        | Orphan Process            | Zombie Process                |
| -------------- | ------------------------- | ----------------------------- |
| State          | Still running             | Terminated (dead)             |
| Parent         | Parent has terminated     | Parent is alive               |
| Resource Usage | Uses CPU and memory       | Uses only process table entry |
| Solution       | Adopted by `init/systemd` | Parent must call `wait()`     |
| Linux State    | Normal running process    | `Z` (defunct)                 |

<hr>

## Memory Management

### 1Ô∏è‚É£ Types of Memory & Need of Memory Management

üîπ Types of Memory
```
Primary Memory ‚Äì RAM, Cache
Secondary Memory ‚Äì HDD, SSD
Virtual Memory ‚Äì Uses disk as extension of RAM
```
üîπ Need of Memory Management
```
Efficient utilization of RAM
Prevent memory conflicts between processes
Support multiprogramming
Provide protection & isolation
Enable virtual memory
```

### 2Ô∏è‚É£ Continuous & Dynamic Allocation

| Feature          | Continuous Allocation                                    | Dynamic Allocation                             |
| ---------------- | -------------------------------------------------------- | ---------------------------------------------- |
| Meaning          | Process gets one **contiguous (single block)** of memory | Memory is allocated **at runtime as needed**   |
| Memory Placement | Stored in a single continuous area                       | Can be allocated and freed during execution    |
| Flexibility      | Less flexible                                            | More flexible                                  |
| Wastage          | Can cause **internal/external fragmentation**            | Reduces wastage by allocating exact size       |
| Example Methods  | Fixed Partition, Variable Partition                      | `malloc()`, `calloc()` in C, `new` in Java/C++ |
| Used In          | Simple OS, early systems                                 | Modern Operating Systems                       |
| Problem          | Fragmentation                                            | Overhead of managing memory                    |

Simple Example
```
Continuous Allocation:
A process needs 100 KB ‚Üí OS must find one free block of 100 KB in a row.

Dynamic Allocation:
A program requests memory during execution:
Memory is given only when required and can be freed later.
```
So:
- Continuous Allocation ‚Üí Memory in one block
- Dynamic Allocation ‚Üí Memory given at runtime as per need

#### üîπ Fixed Size Partition ‚Äì Definition
- Fixed Size Partitioning is a memory management technique in which the main memory is divided into a fixed number of equal-sized partitions before execution begins.
- Each partition can contain only one process.
```
Size and number of partitions are decided in advance.
A process is loaded into any free partition.
If the process is smaller than the partition, the remaining space is wasted (internal fragmentation).
```
- Types of Fixed Size Partitioning

| Type                        | Description                                                                                           |
| --------------------------- | ----------------------------------------------------------------------------------------------------- |
| **Equal Size Partitions**   | All memory partitions are of the **same size**. Every process must fit within that fixed size.        |
| **Unequal Size Partitions** | Memory is divided into partitions of **different fixed sizes** to support processes of varying sizes. |

üîπ Example
```
Equal Size:
100 KB | 100 KB | 100 KB | 100 KB

Unequal Size:
50 KB | 100 KB | 150 KB | 200 KB
```

In both cases:
- One process per partition
- Partition sizes are fixed
- *Wastage inside a partition = Internal Fragmentation* (imp)


### 3Ô∏è‚É£ Allocation Techniques

| Method    | Used in Dynamic Partitioning | Selection Rule                                        |
| --------- | ---------------------------- | ----------------------------------------------------- |
| First Fit | ‚úî Yes                        | First block that fits                                 |
| Best Fit  | ‚úî Yes                        | Smallest block that fits                              |
| Next Fit  | ‚úî Yes                        | First block that fits, starting after last allocation |
| Worst Fit | ‚úî Yes                        | Largest available block                               |


#### Dynamic Partitioning
- First Fit, Best Fit, and Next/Worst Fit are allocation strategies used in Dynamic (Variable) Partitioning of memory.
- Example
```
Free blocks: 100KB, 500KB, 200KB, 300KB
Process = 180KB

First Fit ‚Üí 500KB
Best Fit ‚Üí 200KB
Next Fit ‚Üí Depends on last allocation position
          starts searching after 500 KB ‚Üí checks:
          200 KB ‚Üí fits ‚Üí allocated here
Worst fit ‚Üí 500KB
```

- In Dyanmic Partitioning, external fragmentation occur.
- External Fragmentation is a memory problem in which free memory is available, but it is split into many small non-contiguous blocks (holes).
- Because the free space is scattered, a large process cannot be loaded even though the total free memory is enough.
- It can be reduced using: Compaction (shifting processes to combine free space)

### 4Ô∏è‚É£ Compaction
- Compaction is a technique used to reduce external fragmentation in memory management.
- Before compaction:
```
| P1 | Free | P2 | Free | P3 | Free |
```
- After compaction:
```
| P1 | P2 | P3 | Free (one large block) |
```
- Now a large process can be loaded easily.

- üëâ Compaction is used in:
```
Dynamic (variable) partitioning
Segmentation systems
```
- ‚ö†Ô∏è Disadvantage:
```
Requires moving processes in memory
Time-consuming
Needs hardware support (like relocation and dynamic address binding)
```

### 6Ô∏è‚É£ Segmentation
- Segmentation is a memory management technique in which a program is divided into logical parts called segments.
- Each segment represents a meaningful part of a program, such as:
```
Code
Data
Stack
Heap
Functions
Arrays
```
- Unlike paging, segmentation is based on the logical view of the program, not fixed-size blocks.
- Each segment has: Segment Number
- Base Address ‚Äì starting address of the segment in memory
- Limit ‚Äì size of the segment
- Logical address format:  < Segment Number , Offset >
- The OS uses a Segment Table to convert this logical address into a physical address.
- üîπ Example
```
| Segment No. | Segment Name | Base Address | Limit |
| ----------- | ------------ | ------------ | ----- |
| 0           | Code         | 1000         | 400   |
| 1           | Data         | 2000         | 300   |
| 2           | Stack        | 3000         | 200   |
Logical address: <1, 120>
Physical address = Base(2000) + Offset(120) = 2120
```

### 7Ô∏è‚É£ Paging
- Paging is a memory management technique in which:
```
Physical memory is divided into fixed-size blocks called Frames
Logical memory (process) is divided into same-sized blocks called Pages
```
üîπ Example
```
Assume page size = 100 bytes
| Page No | Frame No |
| ------- | -------- |
| 0       | 5        |
| 1       | 2        |
| 2       | 8        |
| 3       | 1        |

Logical address: <2, 40>
Page 2 ‚Üí Frame 8
Physical address = 8 √ó 100 + 40 = 840
```

üîπ Advantages
```
No external fragmentation
Efficient memory utilization
Supports virtual memory
Easy swapping of pages
```
üîπ Disadvantages
```
Page table overhead
Possible internal fragmentation (unused space in last page)
Extra memory access (page table lookup)
```

### 8Ô∏è‚É£ Dirty Bit
- A Dirty Bit is a flag stored in the page table for each page.
- It indicates whether a page in memory has been modified (written to) after being loaded.
```
Dirty Bit = 0 ‚Üí Page is not modified (clean)
Dirty Bit = 1 ‚Üí Page is modified (dirty)
```
üîπ Why Dirty Bit is Important?
```
When a page needs to be replaced (page replacement):
If Dirty Bit = 0
‚Üí The page is unchanged
‚Üí It can be removed without writing back to disk

If Dirty Bit = 1
‚Üí The page was modified
‚Üí It must be written back to disk before removal

This:
Saves disk I/O
Improves performance
Avoids unnecessary write operations
```

### 9Ô∏è‚É£ Shared Pages & Reentrant Code
üìÑ Shared Pages
- Shared Pages allow multiple processes to use the same physical memory page.
- Commonly used for:
```
System libraries (e.g., C standard library)
Program code that is identical for many processes
Each process has its own page table, but they may point to the same frame.

Benefits:
Saves memory
Faster loading of programs
Efficient use of RAM

Example:
If 10 programs use the same library code, instead of loading it 10 times,
the OS loads it once and shares that page among all processes.
```

üîÅ Reentrant Code
- Reentrant Code is code that can be executed by multiple processes at the same time without any conflict.
- Characteristics:
```
Does not modify itself
Does not use global/static variables
Uses only local variables and parameters
```
Because it is safe for multiple users, reentrant code can be shared.

Example:
```
System functions like printf(), sqrt(), etc. (in libraries)
OS kernel routines
```

üîó Relationship Between Them
| Shared Pages                            | Reentrant Code                              |
| --------------------------------------- | ------------------------------------------- |
| Same memory page used by many processes | Same code executed safely by many processes |
| Saves memory                            | Avoids data corruption                      |
| Usually contains reentrant code         | Suitable for sharing in memory              |


### üîü Throttling
- Throttling is a technique used by the Operating System to control or limit the usage of system resources (CPU, memory, I/O, network, etc.) by processes.
- It prevents any single process or group of processes from overloading the system.
- In simple words: Throttling = Putting a speed limit on resource usage
- hrottling ensures that no process can dominate system resources, keeping the system fair, stable, and efficient.

### 1Ô∏è‚É£1Ô∏è‚É£ I/O Management
- I/O Management is a function of the Operating System that controls and coordinates all input and output devices such as:
```
Keyboard
Mouse
Printer
Disk
Monitor
Network devices
```
- The OS acts as an interface between hardware devices and user programs.

- üîπ Buffering & Spooling (in I/O Management)
- Both Buffering and Spooling are techniques used by the Operating System to improve I/O performance and efficiency.
```
üß∫ Buffering
Buffering uses a small area of main memory (buffer) to temporarily store data while it is being transferred between a device and a process.
Helps match speed between fast CPU and slow I/O devices
Prevents data loss
Improves system performance

Example:
While reading a file from disk, data is first stored in a buffer, then given to the program.

Types:
Single Buffering: Uses one buffer; CPU waits while the buffer is filled or emptied.
Double Buffering: Uses two buffers so one can be filled while the other is processed.
Circular Buffering: Uses multiple buffers in a circular order for continuous data flow without delay.
```
```
üñ®Ô∏è Spooling (Simultaneous Peripheral Operations On-Line)
Spooling stores I/O jobs in a queue on disk so that devices can process them one by one.
Mainly used for slow devices like printers
Allows CPU and devices to work in parallel
Multiple users can send jobs without waiting

Example:
When many users print documents, all print jobs are stored in a print queue.
The printer processes them one by one.
```

<hr>

## Virtual Memory

- Virtual Memory is a memory management technique that allows execution of processes that may not be completely in main memory (RAM).
- Uses secondary storage (disk) as an extension of RAM
- Provides illusion of a large memory
- Only required parts of a program are loaded into RAM
- Advantages:
```
Programs larger than RAM can run
Better memory utilization
More degree of multiprogramming
Faster system response
```
### Demand Paging
- Demand Paging is a virtual memory technique in which a page is loaded into main memory only when it is actually needed (on demand), not in advance.
```
Pages remain on disk until they are referenced.
When a process tries to access a page not in memory, a Page Fault occurs.
The OS then loads that page from disk into RAM.

Working Steps:
Process requests a page
Page not in memory ‚Üí Page Fault
OS finds a free frame
Page is loaded from disk to RAM
Page table is updated
Execution continues
```
üîπ Advantages
```
Less memory usage
Faster program start
Supports large programs in small memory
Efficient use of RAM
```
üîπ Disadvantages
```
Page fault overhead
Slower if too many faults occur (thrashing)
```
- In short: Demand Paging loads pages only when they are needed.

### 3Ô∏è‚É£ Page Fault
- A page fault occurs when:
- A process accesses a page that is not present in main memory.

Steps in handling page fault:
```
Trap to OS
Validate memory reference
Choose a frame (using replacement algorithm if needed)
Read page from disk
Update page table
Restart instruction
```
- Too many page faults cause thrashing (system spends more time swapping than executing).

### 4Ô∏è‚É£ Page Replacement Algorithms

| Algorithm                       | Working                                       | Key Point                             |
| ------------------------------- | --------------------------------------------- | ------------------------------------- |
| **FIFO** (First In First Out)   | Removes oldest page                           | Suffers from **Belady‚Äôs Anomaly**     |
| **LRU** (Least Recently Used)   | Removes least recently used page              | Good performance, costly to implement |
| **Optimal**                     | Removes page not used for longest future time | Best, but theoretical                 |
| **Second Chance**               | FIFO with reference bit                       | Improved FIFO                         |
| **Clock**                       | Circular version of Second Chance             | Efficient                             |
| **LFU** (Least Frequently Used) | Removes least used page                       | Needs counters                        |

<hr>

## Deadlock

### 1Ô∏è‚É£ What is Deadlock?
- A deadlock is a situation where two or more processes are blocked forever because each is waiting for a resource held by another.
Example:
```
Process P1 holds Resource R1 and waits for R2
Process P2 holds Resource R2 and waits for R1
Neither can proceed ‚Üí Deadlock
```
### 2Ô∏è‚É£ Necessary Conditions of Deadlock (Coffman Conditions)

- Deadlock can occur only if all four conditions hold simultaneously:
1. Mutual Exclusion ‚Äì At least one resource is non-shareable
2. Hold and Wait ‚Äì Process holds a resource and waits for another
3. No Preemption ‚Äì Resources cannot be forcibly taken
4. Circular Wait ‚Äì A circular chain of processes exists

- If any one condition is removed, deadlock cannot occur.

### 3Ô∏è‚É£ Deadlock Prevention & Avoidance

üîπ Deadlock Prevention
- Ensure at least one of the four conditions never holds.

| Condition Broken | Technique                                     |
| ---------------- | --------------------------------------------- |
| Mutual Exclusion | Make resources sharable (not always possible) |
| Hold & Wait      | Request all resources at once                 |
| No Preemption    | Preempt resources from waiting process        |
| Circular Wait    | Impose ordering of resources                  |

- üîπ Deadlock Avoidance
```
System checks each request and grants only if it keeps system in safe state
Uses Banker‚Äôs Algorithm
```
- Safe State: A state where system can allocate resources in some order and avoid deadlock.

### 4Ô∏è‚É£ Semaphore
- A semaphore is a synchronization tool used to control access to shared resources.

Operations:
```
wait() / P() ‚Äì Decrement, block if value < 0
signal() / V() ‚Äì Increment, wake waiting process
```
Types:
```
Binary Semaphore ‚Äì 0 or 1
Counting Semaphore ‚Äì Any integer value
```

### 5Ô∏è‚É£ Mutex
- A mutex (Mutual Exclusion) lock allows only one thread to enter a critical section.
- Similar to binary semaphore but:
```
Mutex has ownership (only owner can unlock)
Used mainly for thread synchronization
```

| Semaphore             | Mutex                |
| --------------------- | -------------------- |
| Can be counting       | Only binary          |
| No ownership          | Has ownership        |
| Used for process sync | Used for thread sync |

### 6Ô∏è‚É£ Producer‚ÄìConsumer Problem
- One process (Producer) produces data and puts it in a buffer.
- Another (Consumer) consumes data from the buffer.

Issues:
```
Producer must wait if buffer is full
Consumer must wait if buffer is empty
```
mutex ‚Üí protects critical section
empty ‚Üí counts empty slots
full ‚Üí counts filled slots

### 7Ô∏è‚É£ Deadlock vs Starvation

| Deadlock                                          | Starvation                                   |
| ------------------------------------------------- | -------------------------------------------- |
| Processes wait forever due to circular dependency | Process waits indefinitely due to scheduling |
| Caused by resource cycle                          | Caused by unfair resource allocation         |
| No process progresses                             | Some processes keep progressing              |
| Example: P1 waits for P2, P2 waits for P1         | Low-priority process never gets CPU          |

- These concepts are fundamental for understanding concurrency, synchronization, and safe resource management in operating systems.
